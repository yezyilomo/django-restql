{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Django RESTQL is a python library which allows you to turn your API made with Django REST Framework(DRF) into a GraphQL like API. With Django RESTQL  you will be able to</p> <ul> <li> <p>Send a query to your API and get exactly what you need, nothing more and nothing less.</p> </li> <li> <p>Control the data you get, not the server.</p> </li> <li> <p>Get predictable results, since you control what you get from the server.</p> </li> <li> <p>Get nested resources in a single request.</p> </li> <li> <p>Avoid Over-fetching and Under-fetching of data.</p> </li> <li> <p>Write(create &amp; update) nested data of any level in a single request.</p> </li> </ul> <p>Isn't it cool?.</p>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python &gt;= 3.5</li> <li>Django &gt;= 1.11</li> <li>Django REST Framework &gt;= 3.5</li> </ul>"},{"location":"#installing","title":"Installing","text":"<pre><code>pip install django-restql\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Using Django RESTQL to query data is very simple, you just have to inherit the <code>DynamicFieldsMixin</code> class when defining a serializer that's all.</p> <pre><code>from rest_framework import serializers\nfrom django.contrib.auth.models import User\nfrom django_restql.mixins import DynamicFieldsMixin\n\n\nclass UserSerializer(DynamicFieldsMixin, serializer.ModelSerializer):\n    class Meta:\n        model = User\n        fields = ['id', 'username', 'email']\n</code></pre> <p>Django RESTQL handle all requests with a <code>query</code> parameter, this parameter is the one used to pass all fields to be included/excluded in a response. For example to select <code>id</code> and <code>username</code> fields from User model, send a request with a <code>query</code> parameter as shown below.</p> <p><code>GET /users/?query={id, username}</code></p> <pre><code>[\n    {\n        \"id\": 1,\n        \"username\": \"yezyilomo\"\n    },\n    ...\n]\n</code></pre> <p>Django RESTQL support querying both flat and nested resources, you can expand or query nested fields at any level as defined on a serializer. It also supports querying with all HTTP methods i.e (GET, POST, PUT &amp; PATCH)</p> <p>You can do a lot with Django RESTQL apart from querying data, like</p> <ul> <li>Rename fields</li> <li>Restrict some fields on nested fields</li> <li>Define self referencing nested fields</li> <li>Optimize data fetching on nested fields</li> <li>Data filtering and pagination by using query arguments</li> <li>Data mutation(Create and update nested data of any level in a single request)</li> </ul>"},{"location":"#django-restql-play-ground","title":"Django RESTQL Play Ground","text":"<p>Django RESTQL Play Ground is a graphical, interactive, in-browser tool which you can use to test Django RESTQL features like data querying, mutations etc to get the idea of how the library works before installing it. It's more like a live demo for Django RESTQL, it's available at https://django-restql-playground.yezyilomo.me</p>"},{"location":"license/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2019 Yezy Ilomo</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"mutating_data/","title":"Mutating Data","text":"<p>Django RESTQL got your back on creating and updating nested data too, it has two components for mutating nested data, <code>NestedModelSerializer</code> and <code>NestedField</code>. A serializer <code>NestedModelSerializer</code> has <code>update</code> and <code>create</code> logics for nested fields on the other hand <code>NestedField</code> is used to validate data before calling <code>update</code> or <code>create</code> method.</p>"},{"location":"mutating_data/#using-nestedfield-and-nestedmodelserializer","title":"Using NestedField and NestedModelSerializer","text":"<p>Just like in querying data, mutating nested data with Django RESTQL is very simple, you just have to inherit <code>NestedModelSerializer</code> on a serializer with nested fields and use <code>NestedField</code> to define those nested fields which you want to be able to mutate. Below is an example which shows how to use <code>NestedModelSerializer</code> and <code>NestedField</code>.</p> <pre><code>from rest_framework import serializers\nfrom django_restql.serializers import NestedModelSerializer\nfrom django_restql.fields import NestedField\n\nfrom app.models import Location, Amenity, Property\n\n\nclass LocationSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Location\n        fields = [\"id\", \"city\", \"country\"]\n\n\nclass AmenitySerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Amenity\n        fields = [\"id\", \"name\"]\n\n\n# Inherit NestedModelSerializer to support create and update \n# on nested fields\nclass PropertySerializer(NestedModelSerializer):\n    # Define location as nested field\n    location = NestedField(LocationSerializer)\n\n    # Define amenities as nested field\n    amenities = NestedField(AmenitySerializer, many=True)\n    class Meta:\n        model = Property\n        fields = [\n            'id', 'price', 'location', 'amenities'\n        ]\n</code></pre> <p>With serializers defined as shown above, you will be able to send data mutation request like</p> <p><code>POST /api/property/</code></p> <p>With a request body like</p> <pre><code>{\n    \"price\": 60000,\n    \"location\": {\n        \"city\": \"Newyork\",\n        \"country\": \"USA\"\n    },\n    \"amenities\": {\n        \"add\": [3],\n        \"create\": [\n            {\"name\": \"Watererr\"},\n            {\"name\": \"Electricity\"}\n        ]\n    }\n}\n</code></pre> <p>And get a response as</p> <pre><code>{\n    \"id\": 2,\n    \"price\": 60000,\n    \"location\": {\n        \"id\": 3,\n        \"city\": \"Newyork\",\n        \"country\": \"USA\"\n    },\n    \"amenities\": [\n        {\"id\": 1, \"name\": \"Watererr\"},\n        {\"id\": 2, \"name\": \"Electricity\"},\n        {\"id\": 3, \"name\": \"Swimming Pool\"}\n    ]\n}\n</code></pre> <p>Just to clarify what happed here:</p> <ul> <li>location has been created and associated with the property created</li> <li><code>create</code> operation has created amenities with values specified in a list and associate them with the property</li> <li><code>add</code> operation has added amenity with id=3 to a list of amenities of the property.</li> </ul> <p>Note</p> <p>POST for many related fields supports two operations which are <code>create</code> and <code>add</code>.</p> <p></p> <p>Below we have an example where we are trying to update the property we have created in the previous example.</p> <p><code>PUT/PATCH /api/property/2/</code></p> <p>Request Body</p> <pre><code>{\n    \"price\": 50000,\n    \"location\": {\n        \"city\": \"Newyork\",\n        \"country\": \"USA\"\n    },\n    \"amenities\": {\n        \"add\": [4],\n        \"create\": [{\"name\": \"Fance\"}],\n        \"remove\": [3],\n        \"update\": {1: {\"name\": \"Water\"}}\n    }\n}\n</code></pre> <p>After sending the requst above we'll get a response which looks like</p> <pre><code>{\n    \"id\": 2,\n    \"price\": 50000,\n    \"location\": {\n        \"id\": 3,\n        \"city\": \"Newyork\",\n        \"country\": \"USA\"\n    },\n    \"amenities\": [\n        {\"id\": 1, \"name\": \"Water\"},\n        {\"id\": 2, \"name\": \"Electricity\"},\n        {\"id\": 4, \"name\": \"Bathtub\"},\n        {\"id\": 5, \"name\": \"Fance\"}\n    ]\n}\n</code></pre> <p>From the request body <code>add</code>, <code>create</code>, <code>remove</code> and <code>update</code> are operations</p> <p>What you see in the response above are details of our property, what really happened after sending the update request is</p> <ul> <li><code>add</code> operation added amenitiy with id=4 to a list of amenities of the property</li> <li><code>create</code> operation created amenities with values specified in a list</li> <li><code>remove</code> operation removed amenities with id=3 from a property</li> <li><code>update</code> operation updated amenity with id=1 according to values specified.</li> </ul> <p>Note</p> <p>PUT/PATCH for many related fields supports four operations which are <code>create</code>, <code>add</code>, <code>remove</code> and <code>update</code>.</p>"},{"location":"mutating_data/#self-referencing-nested-field","title":"Self referencing nested field","text":"<p>Currently DRF doesn't allow declaring self referencing nested fields but you might have a self referencing nested field in your project since Django allows creating them. Django RESTQL comes with a nice way to deal with this scenario.</p> <p>Let's assume we have a student model as shows below</p> <pre><code># models.py\n\nclass Student(models.Model):\n    name = models.CharField(max_length=50)\n    age = models.IntegerField()\n    study_partners = models.ManyToManyField('self', related_name='study_partners')\n</code></pre> <p>As you can see from the model above <code>study_partners</code> is a self referencing field. Below is the corresponding serializer for our model</p> <pre><code># serializers.py\n\nclass StudentSerializer(NestedModelSerializer):\n    # Define study_partners as self referencing nested field\n    study_partners = NestedField(\n        'self',\n        many=True,\n        required=False,\n        exclude=['study_partners']\n    )\n\n    class Meta:\n        model = Student\n        fields = ['id', 'name', 'age', 'study_partners']\n</code></pre> <p>You can see that we have passed <code>self</code> to <code>NestedField</code> just like in <code>Student</code> model, this means that <code>study_partners</code> field is a self referencing field.</p> <p>The other important thing here is <code>exclude=['study_partners']</code>, this excludes the field <code>study_partners</code> on a nested field to avoid recursion error if the self reference is cyclic.</p>"},{"location":"mutating_data/#nestedfield-kwargs","title":"NestedField kwargs","text":"<p><code>NestedField</code> accepts extra kwargs in addition to those accepted by a serializer, these extra kwargs can be used to do more customizations on a nested field as explained below.</p>"},{"location":"mutating_data/#accept_pk-kwarg","title":"accept_pk kwarg","text":"<p><code>accept_pk=True</code> is used if you want to be able to update nested field by using pk/id of existing data(basically associate existing nested resource with the parent resource). This applies to foreign key relations only. The default value for <code>accept_pk</code> is <code>False</code>.</p> <p>Below is an example showing how to use <code>accept_pk</code> kwarg.</p> <pre><code>from rest_framework import serializers \nfrom django_restql.fields import NestedField\nfrom django_restql.serializers import NestedModelSerializer\n\nfrom app.models import Location, Property\n\n\nclass LocationSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Location\n        fields = [\"id\", \"city\", \"country\"]\n\n\nclass PropertySerializer(NestedModelSerializer):\n    # pk based nested field\n    location = NestedField(LocationSerializer, accept_pk=True)\n    class Meta:\n        model = Property\n        fields = [\n            'id', 'price', 'location'\n        ]\n</code></pre> <p>Now sending mutation request as</p> <p><code>POST /api/property/</code></p> <p>Request Body</p> <pre><code>{\n    \"price\": 40000,\n    \"location\": 2\n}\n</code></pre> <p>Note</p> <p>Here location resource with id=2 exists already, so what's done here is create a new property resource and associate it with this location whose id is 2.</p> <p>Response</p> <pre><code>{\n    \"id\": 1,\n    \"price\": 40000,\n    \"location\": {\n        \"id\": 2,\n        \"city\": \"Tokyo\",\n        \"country\": \"China\"\n    }\n}\n</code></pre> <p>Using <code>accept_pk</code> doesn't limit you from sending data(instead of pk to nested resource), setting <code>accept_pk=True</code> means you can send both data and pks. For instance from the above example you could still do </p> <p><code>POST /api/property/</code></p> <p>Request Body</p> <pre><code>{\n    \"price\": 63000,\n    \"location\": {\n        \"city\": \"Dodoma\",\n        \"country\": \"Tanzania\"\n    }\n}\n</code></pre> <p>Response</p> <pre><code>{\n    \"id\": 2,\n    \"price\": 63000,\n    \"location\": {\n        \"id\": 3,\n        \"city\": \"Dodoma\",\n        \"country\": \"Tanzania\"\n    }\n}\n</code></pre>"},{"location":"mutating_data/#accept_pk_only-kwarg","title":"accept_pk_only kwarg","text":"<p><code>accept_pk_only=True</code> is used if you want to be able to update nested field by using pk/id only. This applies to foreign key relations only as well. The default value for <code>accept_pk_only</code> kwarg is <code>False</code>, if <code>accept_pk_only=True</code> is set you won't be able to send data to create a nested resource.</p> <p>Below is an example showing how to use <code>accept_pk_only</code> kwarg.</p> <pre><code>from rest_framework import serializers \nfrom django_restql.fields import NestedField\nfrom django_restql.serializers import NestedModelSerializer\n\nfrom app.models import Location, Property\n\n\nclass LocationSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Location\n        fields = [\"id\", \"city\", \"country\"]\n\n\nclass PropertySerializer(NestedModelSerializer):\n    # pk based nested field\n    location = NestedField(LocationSerializer, accept_pk_only=True)\n    class Meta:\n        model = Property\n        fields = [\n            'id', 'price', 'location'\n        ]\n</code></pre> <p>Sending mutation request</p> <p><code>POST /api/property/</code></p> <p>Request Body</p> <pre><code>{\n    \"price\": 40000,\n    \"location\": 2  // You can't send data in here, you can only send pk/id\n}\n</code></pre> <p>Response</p> <pre><code>{\n    \"id\": 1,\n    \"price\": 40000,\n    \"location\": {\n        \"id\": 2,\n        \"city\": \"Tokyo\",\n        \"country\": \"China\"\n    }\n}\n</code></pre> <p>Note</p> <p>By default <code>accept_pk=False</code> and <code>accept_pk_only=False</code>, so nested field(foreign key related) accepts data only by default, if <code>accept_pk=True</code> is set, it accepts data and pk/id, and if <code>accept_pk_only=True</code> is set it accepts pk/id only. You can't set both <code>accept_pk=True</code> and <code>accept_pk_only=True</code>.</p>"},{"location":"mutating_data/#create_ops-and-update_ops-kwargs","title":"create_ops and update_ops kwargs.","text":"<p>These two kwargs are used to restrict some operations when creating or updating nested data. Below is an example showing how to restrict some operations by using these two kwargs.</p> <pre><code>from rest_framework import serializers \nfrom django_restql.fields import NestedField\nfrom django_restql.serializers import NestedModelSerializer \n\nfrom app.models import Location, Amenity, Property\n\n\nclass AmenitySerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Amenity\n        fields = [\"id\", \"name\"]\n\n\nclass PropertySerializer(NestedModelSerializer):\n    amenities = NestedField(\n        AmenitySerializer, \n        many=True,\n        create_ops=[\"add\"],  # Allow only add operation\n        update_ops=[\"add\", \"remove\"]  # Allow only add and remove operations\n    )\n    class Meta:\n        model = Property\n        fields = [\n            'id', 'price', 'amenities'\n        ]\n</code></pre> <p>Sending create mutation request</p> <p><code>POST /api/property/</code></p> <p>Request Body</p> <pre><code>{\n    \"price\": 60000,\n    \"amenities\": {\n        \"add\": [1, 2]\n    }\n}\n</code></pre> <p>Note</p> <p>Since <code>create_ops=[\"add\"]</code>, you can't use <code>create</code> operation in here!.</p> <p>Response</p> <pre><code>{\n    \"id\": 2,\n    \"price\": 60000,\n    \"amenities\": [\n        {\"id\": 1, \"name\": \"Watererr\"},\n        {\"id\": 2, \"name\": \"Electricity\"}\n    ]\n}\n</code></pre> <p>Sending update mutation request</p> <p><code>PUT/PATCH /api/property/2/</code></p> <p>Request Body</p> <pre><code>{\n    \"price\": 50000,\n    \"amenities\": {\n        \"add\": [3],\n        \"remove\": [2]\n    }\n}\n</code></pre> <p>Note</p> <p>Since <code>update_ops=[\"add\", \"remove\"]</code>, you can't use <code>create</code> or <code>update</code> operation in here!.</p> <p>Response</p> <pre><code>{\n    \"id\": 2,\n    \"price\": 50000,\n    \"amenities\": [\n        {\"id\": 1, \"name\": \"Water\"},\n        {\"id\": 3, \"name\": \"Bathtub\"}\n    ]\n}\n</code></pre>"},{"location":"mutating_data/#allow_remove_all-kwarg","title":"allow_remove_all kwarg","text":"<p>This kwarg is used to enable and disable removing all related objects on many related nested field at once by using <code>__all__</code> directive. The default value of <code>allow_remove_all</code> is <code>False</code>, which means removing all related objects on many related nested fields is disabled by default so if you want to enable it you must set its value to <code>True</code>. For example </p> <pre><code>class CourseSerializer(NestedModelSerializer):\n    books = NestedField(BookSerializer, many=True, allow_remove_all=True)\n\n    class Meta:\n        model = Course\n        fields = [\"name\", \"code\", \"books\"]\n</code></pre> <p>With <code>allow_remove_all=True</code> as set above you will be able to send a request like</p> <p><code>PUT/PATCH /courses/3/</code></p> <p>Request Body</p> <pre><code>{\n    \"books\": {\n        \"remove\":  \"__all__\"\n    }\n}\n</code></pre> <p>This will remove all books associated with a course being updated. </p>"},{"location":"mutating_data/#delete_on_null-kwarg","title":"delete_on_null kwarg","text":"<p>When dealing with nested fields, there are scenarios where the previously assigned object or resource is no longer needed after the field is cleared (i.e. set to <code>null</code>). In such cases, passing <code>delete_on_null=True</code> kwarg enables automatic deletion of the previously assigned resource when the nested field is explicitly updated to <code>null</code>.</p> <p>This keyword argument applies only to <code>ForeignKey</code> or <code>OneToOne</code> relationships. The default value for <code>delete_on_null</code> kwarg is <code>False</code>.</p> <p>Below is an example showing how to use <code>delete_on_null</code> kwarg.</p> <pre><code>from rest_framework import serializers \nfrom django_restql.fields import NestedField\nfrom django_restql.serializers import NestedModelSerializer\n\nfrom app.models import Location, Property\n\n\nclass LocationSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Location\n        fields = [\"id\", \"city\", \"country\"]\n\n\nclass PropertySerializer(NestedModelSerializer):\n    location = NestedField(LocationSerializer, delete_on_null=True)\n    class Meta:\n        model = Property\n        fields = [\n            'id', 'price', 'location'\n        ]\n</code></pre> <p>Assuming we have a property with this structure</p> <pre><code>{\n    \"id\": 1,\n    \"price\": 30000,\n    \"location\": {\n        \"id\": 5,\n        \"city\": \"Arusha\",\n        \"country\": \"Tanzania\"\n    }\n}\n</code></pre> <p>Sending a mutation request to update this property by removing a location</p> <p><code>PUT/PATCH  /api/property/1/</code></p> <p>Request Body</p> <pre><code>{\n    \"location\": null\n}\n</code></pre> <p>Response</p> <pre><code>{\n    \"id\": 1,\n    \"price\": 30000,\n    \"location\": null\n}\n</code></pre> <p>In this case, the property\u2019s location is updated to null, and the previously assigned Location instance (with id: 5) is deleted from the database.</p> <p>Note</p> <p><code>delete_on_null=True</code> can only be used when both <code>accept_pk=False</code> and <code>accept_pk_only=False</code>. This is because <code>accept_pk=True</code> or <code>accept_pk_only=True</code> typically implies that the nested object is not tightly coupled to the parent and may be referenced elsewhere. Automatically deleting it in such cases could lead to unintended side effects or broken references.</p>"},{"location":"mutating_data/#using-dynamicfieldsmixin-and-nestedfield-together","title":"Using DynamicFieldsMixin and NestedField together","text":"<p>You can use <code>DynamicFieldsMixin</code> and <code>NestedModelSerializer</code> together if you want your serializer to be writable(on nested fields) and support querying data, this is very common. Below is an example which shows how you can use <code>DynamicFieldsMixin</code> and <code>NestedField</code> together.</p> <pre><code>from rest_framework import serializers \nfrom django_restql.fields import NestedField\nfrom django_restql.mixins import DynamicFieldsMixin\nfrom django_restql.serializers import NestedModelSerializer \n\nfrom app.models import Location, Property\n\n\nclass LocationSerializer(DynamicFieldsMixin, serializers.ModelSerializer):\n    class Meta:\n        model = Location\n        fields = [\"id\", \"city\", \"country\"]\n\n# Inherit both DynamicFieldsMixin and NestedModelSerializer\nclass PropertySerializer(DynamicFieldsMixin, NestedModelSerializer):\n    location = NestedField(LocationSerializer)\n    class Meta:\n        model = Property\n        fields = [\n            'id', 'price', 'location'\n        ]\n</code></pre> <p><code>NestedField</code> is nothing but a serializer wrapper, it returns an instance of a modified version of a serializer passed, so you can pass all the args and kwargs accepted by a serializer on it, it will simply pass them along to a serializer passed when instantiating an instance. So you can pass anything accepted by a serializer to a <code>NestedField</code> wrapper, and if a serializer passed inherits <code>DynamicFieldsMixin</code> just like <code>LocationSerializer</code> on the example above then you can pass any arg or kwarg accepted by <code>DynamicFieldsMixin</code> when defining location as a nested field, i.e</p> <pre><code>location = NestedField(LocationSerializer, fields=[...])\n</code></pre> <pre><code>location = NestedField(LocationSerializer, exclude=[...])\n</code></pre> <pre><code>location = NestedField(LocationSerializer, return_pk=True)\n</code></pre> <p>Note</p> <p>If you want to use <code>required=False</code> kwarg on <code>NestedField</code> you might want to include <code>allow_null=True</code> too if you want your nested field to be set to <code>null</code> if you haven't supplied it. For example </p> <pre><code>from rest_framework import serializers \nfrom django_restql.fields import NestedField\nfrom django_restql.mixins import DynamicFieldsMixin\nfrom django_restql.serializers import NestedModelSerializer \n\nfrom app.models import Location, Property\n\n\nclass LocationSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Location\n        fields = [\"id\", \"city\", \"country\"]\n\n\nclass PropertySerializer(NestedModelSerializer):\n    # Passing both `required=False` and `allow_null=True`\n    location = NestedField(LocationSerializer, required=False, allow_null=True)\n    class Meta:\n        model = Property\n        fields = [\n            'id', 'price', 'location'\n        ]\n</code></pre> <p>The <code>required=False</code> kwarg allows you to create Property without including <code>location</code> field and the <code>allow_null=True</code> kwarg allows <code>location</code> field to be set to null if you haven't supplied it. For example</p> <p>Sending mutation request</p> <p><code>POST /api/property/</code></p> <p>Request Body</p> <pre><code>{\n    \"price\": 40000\n    // You can see that the location is not included here\n}\n</code></pre> <p>Response</p> <pre><code>{\n    \"id\": 2,\n    \"price\": 50000,\n    \"location\": null  // This is the result of not including location\n}\n</code></pre> <p>If you use <code>required=False</code> only without <code>allow_null=True</code>, The serializer will allow you to create Property without including <code>location</code> field but it will throw error because by default <code>allow_null=False</code> which means <code>null</code>/<code>None</code>(which is what's passed when you don't supply <code>location</code> value) is not considered a valid value.</p>"},{"location":"mutating_data/#working-with-data-mutation-without-request","title":"Working with data mutation without request","text":"<p>Django RESTQL allows you to do data mutation without having request object, this is used if you don't want to get your mutation data input(serializer data) from a request, in fact <code>NestedModelSerializer</code> and <code>NestedFied</code> can work independently without using request. Below is an example showing how you can work with data mutation without request object.</p> <pre><code>from rest_framework import serializers\nfrom django_restql.fields import NestedField\nfrom django_restql.mixins import DynamicFieldsMixin\nfrom django_restql.serializers import NestedModelSerializer\n\nfrom app.models import Book, Course\n\n\nclass BookSerializer(DynamicFieldsMixin, NestedModelSerializer):\n    class Meta:\n        model = Book\n        fields = ['id', 'title', 'author']\n\n\nclass CourseSerializer(DynamicFieldsMixin, NestedModelSerializer):\n    books = NestedField(BookSerializer, many=True, required=False)\n    class Meta:\n        model = Course\n        fields = ['id', 'name', 'code', 'books']\n</code></pre> <p>From serializers above you can create a course like</p> <pre><code>data = {\n    \"name\": \"Computer Programming\",\n    \"code\": \"CS50\",\n    \"books\": {\n        \"add\": [1, 2],\n        \"create\": [\n            {'title': 'Basic Data Structures', 'author': 'J. Davis'},\n            {'title': 'Advanced Data Structures', 'author': 'S. Mobit'}\n        ]\n    }\n}\n\nserializer = CourseSerializer(data=data)\nserializer.is_valid()\nserializer.save()\n\nprint(serializer.data)\n\n# This will print\n{\n    \"id\": 2,\n    \"name\": \"Computer Programming\",\n    \"code\": \"CS50\",\n    \"books\": [\n        {'id': 1, 'title': 'Programming Intro', 'author': 'K. Moses'},\n        {'id': 2, 'title': 'Understanding Computers', 'author': 'B. Gibson'},\n        {'id': 3, 'title': 'Basic Data Structures', 'author': 'J. Davis'},\n        {'id': 4, 'title': 'Advanced Data Structures', 'author': 'S. Mobit'}\n    ]\n}\n</code></pre> <p>To update a created course you can do it like</p> <pre><code>data = {\n    \"code\": \"CS100\",\n    \"books\": {\n        \"remove\": [2, 3]\n    }\n}\n\ncourse_obj = Course.objects.get(pk=2)\n\nserializer = CourseSerializer(course_obj, data=data)\nserializer.is_valid()\nserializer.save()\n\nprint(serializer.data)\n\n# This will print\n{\n    \"id\": 2,\n    \"name\": \"Computer Programming\",\n    \"code\": \"CS100\",\n    \"books\": [\n        {'id': 1, 'title': 'Programming Intro', 'author': 'K. Moses'},\n        {'id': 2, 'title': 'Understanding Computers', 'author': 'B. Gibson'}\n    ]\n}\n</code></pre>"},{"location":"querying_data/","title":"Querying Data","text":"<p>Django RESTQL makes data querying(selecting fields to include in a response) way easier, if you want to use it to query data you just have to inherit the <code>DynamicFieldsMixin</code> class when defining your serializer, that's all. Below is an example showing how to use <code>DynamicFieldsMixin</code>.</p> <pre><code>from rest_framework import serializers\nfrom django.contrib.auth.models import User\nfrom django_restql.mixins import DynamicFieldsMixin\n\n\nclass UserSerializer(DynamicFieldsMixin, serializer.ModelSerializer):\n    class Meta:\n        model = User\n        fields = ['id', 'username', 'email']\n</code></pre> <p>Here a regular request returns all fields as specified on a DRF serializer, in fact Django RESTQL doesn't handle this(regular) request at all. Below is an example of a regular request and its response </p> <p><code>GET /users</code></p> <pre><code>[\n    {\n        \"id\": 1,\n        \"username\": \"yezyilomo\",\n        \"email\": \"yezileliilomo@hotmail.com\",\n    },\n    ...\n]\n</code></pre> <p>As you can see all fields have been returned as specified on <code>UserSerializer</code>.</p> <p>Django RESTQL handle all requests with a <code>query</code> parameter, this parameter is the one which is used to pass all fields to be included/excluded in a response.</p> <p>For example to select <code>id</code> and <code>username</code> fields from User model, send a request with a <code>query</code> parameter as shown below.</p> <p><code>GET /users/?query={id, username}</code></p> <pre><code>[\n    {\n        \"id\": 1,\n        \"username\": \"yezyilomo\"\n    },\n    ...\n]\n</code></pre> <p>You can see only <code>id</code> and <code>username</code> fields have been returned in a response as specified on a <code>query</code> parameter.</p>"},{"location":"querying_data/#querying-nested-fields","title":"Querying nested fields","text":"<p>Django RESTQL support querying both flat and nested data, so you can expand or query nested fields at any level as defined on a serializer. In an example below we have <code>location</code> and <code>groups</code> as nested fields on User model.</p> <pre><code>from rest_framework import serializers\nfrom django.contrib.auth.models import User\nfrom django_restql.mixins import DynamicFieldsMixin\n\nfrom app.models import GroupSerializer, LocationSerializer\n\n\nclass GroupSerializer(DynamicFieldsMixin, serializer.ModelSerializer):\n    class Meta:\n        model = Group\n        fields = ['id', 'name']\n\n\nclass LocationSerializer(DynamicFieldsMixin, serializer.ModelSerializer):\n    class Meta:\n        model = Location\n        fields = ['id', 'country',  'city', 'street']\n\n\nclass UserSerializer(DynamicFieldsMixin, serializer.ModelSerializer):\n    groups = GroupSerializer(many=True, read_only=True)\n    location = LocationSerializer(many=False, read_only=True) \n    class Meta:\n        model = User\n        fields = ['id', 'username', 'email', 'location', 'groups']\n</code></pre> <p>If you want to retrieve user's <code>id</code>, <code>username</code> and <code>location</code> fields but under <code>location</code> field you want to get only <code>country</code> and <code>city</code> fields here is how you can do it</p> <p><code>GET /users/?query={id, username, location{country, city}}</code></p> <pre><code>[\n    {\n        \"id\": 1,\n        \"username\": \"yezyilomo\",\n        \"location\": {\n            \"contry\": \"Tanzania\",\n            \"city\": \"Dar es salaam\"\n        }\n    },\n    ...\n]\n</code></pre> More examples to get you comfortable with the query syntax <p><code>GET /users/?query={location, groups}</code></p> <pre><code>[\n    {\n        \"location\": {\n            \"id\": 1,\n            \"contry\": \"Tanzania\",\n            \"city\": \"Dar es salaam\",\n            \"street\": \"Oyster Bay\"\n        }\n        \"groups\": [\n            {\"id\": 2, \"name\": \"Auth_User\"},\n            {\"id\": 3, \"name\": \"Admin_User\"}\n        ]\n    },\n    ...\n]\n</code></pre> <p></p> <p><code>GET /users/?query={id, username, groups{name}}</code></p> <pre><code>[\n    {\n        \"id\": 1,\n        \"username\": \"yezyilomo\",\n        \"groups\": [\n            {\"name\": \"Auth_User\"},\n            {\"name\": \"Admin_User\"}\n        ]\n    },\n    ...\n]\n</code></pre> <p>Note</p> <p>Using commas(<code>,</code>) to separate fields and arguments is optional, you can use spaces too just like in GraphQL For example you could write your query as <code>query={id  username  location{country  city}}</code> so the choice is yours.</p>"},{"location":"querying_data/#exclude-operator","title":"Exclude(-) operator","text":"<p>Using Django RESTQL filtering as it is when there are no many fields on a serializer is great, but sometimes you might have a case where you would like everything except a handful of fields on a larger serializer. These fields might be nested and trying the whitelist approach might possibly be too long for the url. </p> <p>Django RESTQL comes with the exclude(-) operator which can be used to exclude some fields in scenarios where you want to get all fields except few ones. Using exclude operator is very simple, you just need to prepend the exclude(-) operator to the field which you want to exclude when writing your query that's all. Take an example below</p> <pre><code>from rest_framework import serializers \nfrom django_restql.mixins import DynamicFieldsMixin\n\nfrom app.models import Location, Property\n\n\nclass LocationSerializer(DynamicFieldsMixin, serializer.ModelSerializer):\n    class Meta:\n        model = Location\n        fields = [\"id\", \"city\", \"country\", \"state\", \"street\"]\n\n\nclass PropertySerializer(DynamicFieldsMixin, serializer.ModelSerializer):\n    location = LocationSerializer(many=False, read_only=True) \n    class Meta:\n        model = Property\n        fields = [\n            'id', 'price', 'location'\n        ]\n</code></pre> <p>If we want to get all fields under <code>LocationSerializer</code> except <code>id</code> and <code>street</code>, by using the exclude(-) operator we could do it as follows</p> <p><code>GET /location/?query={-id, -street}</code></p> <pre><code>[\n    {\n        \"country\": \"China\",\n        \"city\": \"Beijing\",\n        \"state\": \"Chaoyang\"\n    },\n    ...\n]\n</code></pre> <p>This is equivalent to <code>query={country, city, state}</code></p> <p>You can use exclude operator on nested fields too, for example if you want to get <code>price</code> and <code>location</code> fields but under <code>location</code> you want all fields except <code>id</code> here is how you could do it.</p> <p><code>GET /property/?query={price, location{-id}}</code></p> <pre><code>[\n    {\n        \"price\": 5000\n        \"location\": {\n            \"country\": \"China\",\n            \"city\" \"Beijing\",\n            \"state\": \"Chaoyang\",\n            \"street\": \"Hanang\"\n        }\n    },\n    ...\n]\n</code></pre> <p>This is equivalent to <code>query={price, location{country, city, state, street}}</code></p> More examples to get you comfortable with the exclude(-) operator <p>Assuming this is the structure of the model we are querying</p> <pre><code>data = {\n    username,\n    birthdate,\n    location {\n        country,\n        city\n    },\n    contact {\n        phone,\n        email\n    }\n}\n</code></pre> <p>Here is how we can structure our queries to exclude some fields by using exclude(-) operator</p> <pre><code>{-username}   \u2261   {birthdate, location{country, city}, contact{phone, email}}\n\n{-username, contact{phone}, location{country}}   \u2261    {birthdate ,contact{phone}, location{country}}\n\n{-contact, location{country}}   \u2261    {username, birthdate, location{country}}\n\n{-contact, -location}   \u2261    {username, birthdate}\n\n{username, location{-country}}   \u2261    {username, location{city}}\n\n{username, location{-city}, contact{-email}}   \u2261    {username, location{country}, contact{phone}}\n</code></pre>"},{"location":"querying_data/#wildcard-operator","title":"Wildcard(*) operator","text":"<p>In addition to the exclude(-) operator, Django RESTQL comes with a wildcard(*) operator for including all fields. Using a wildcard(*) operator is very simple, for example if you want to get all fields from a model by using a wildcard(*) operator you could simply write your query as </p> <p><code>query={*}</code></p> <p>This operator can be used to simplify some filtering which might endup being very long if done with other approaches. For example if you have a model with this format </p> <pre><code>user = {\n    username,\n    birthdate,\n    contact {\n        phone,\n        email,\n        twitter,\n        github,\n        linkedin,\n        facebook\n    }\n}\n</code></pre> <p>Let's say you want to get all user fields but under <code>contact</code> field you want to get only <code>phone</code>, you could use the whitelisting approach and write your query as </p> <p><code>query={username, birthdate, contact{phone}}</code> </p> <p>but if you have many fields on user model you might endup writing a very long query, such problem can be avoided by using a wildcard(*) operator which in our case we could simply write the query as</p> <p><code>query={*, contact{phone}}</code></p> <p>The above query means \"get me all fields on user model but under <code>contact</code> field get only <code>phone</code> field\". As you can see the query became very short compared to the first one after using wildcard(*) operator and it won't grow if more fields are added to a user model.</p> More examples to get you comfortable with the wildcard(*) operator <pre><code>{*, -username, contact{phone}}   \u2261   {birthdate, contact{phone}}\n\n{username, contact{*, -facebook, -linkedin}}   \u2261   {username, contact{phone, email, twitter, github}}\n\n{*, -username, contact{*, -facebook, -linkedin}}   \u2261   {birthdate, contact{phone, email, twitter, github}}\n</code></pre> <p>Below is a list of mistakes which leads to query syntax/format error, these mistakes may happen accidentally as it's very easy/tempting to make them with the exclude(-) operator and wildcard(*) operator syntax.</p> <pre><code>{username, -location{country}}  # Should not expand excluded field\n{*username}  # What are you even trying to accomplish\n{*location{country}}  # This is definitely wrong\n</code></pre>"},{"location":"querying_data/#aliases","title":"Aliases","text":"<p>When working with API, you may want to rename a field to something other than what the API has to offer. Aliases exist as part of this library to solve this exact problem.</p> <p>Aliases allow you to rename a single field to whatever you want it to be. They are defined at the client side, so you don\u2019t need to update your API to use them.</p> <p>Imagine requesting data using the following query from an API:</p> <p><code>GET /users/?query={id, updated_at}</code></p> <p>You will get the following JSON response:</p> <pre><code>[\n    {\n        \"id\": 1,\n        \"updated_at\": \"2021-05-05T21:05:23.034Z\"\n    },\n    ...\n]\n</code></pre> <p>The id here is fine, but the <code>updated_at</code> doesn\u2019t quite conform to the camel case convention in JavaScript(Which is where APIs are used mostly). Let\u2019s change it by using an alias.</p> <p><code>GET /users/?query={id, updatedAt: updated_at}</code></p> <p>Which yields the following:</p> <pre><code>[\n    {\n        \"id\": 1,\n        \"updatedAt\": \"2021-05-05T21:05:23.034Z\"\n    },\n    ...\n]\n</code></pre> <p>Creating an alias is very easy just like in GraphQL. Simply add a new name and a colon(:) before the field you want to rename.</p> More examples <p>Renaming <code>date_of_birth</code> to <code>dateOfBirth</code>, <code>course</code> to <code>programme</code> and <code>books</code> to <code>readings</code></p> <p><code>GET /students/?query={name, dateOfBirth: date_of_birth, programme: course{id, name, readings: books}}</code></p> <p>This yields</p> <pre><code>[\n    {\n        \"name\": \"Yezy Ilomo\",\n        \"dateOfBirth\": \"04-08-1995\",\n        \"programme\": {\n            \"id\": 4,\n            \"name\": \"Computer Science\",\n            \"readings\": [\n                {\"id\": 1, \"title\": \"Alogarithms\"},\n                {\"id\": 2, \"title\": \"Data Structures\"},\n            ]\n        }\n    },\n    ...\n]\n</code></pre> <p>Note</p> <p>The default maximum length of alias is 50 characters, it's controlled by <code>MAX_ALIAS_LEN</code> setting. This is enforced to prevent DoS like attacks to API which might be caused by clients specifying a really really long alias which may increase network usage. For more information about <code>MAX_ALIAS_LEN</code> setting and how to change it go to this section.</p>"},{"location":"querying_data/#dynamicserializermethodfield","title":"DynamicSerializerMethodField","text":"<p><code>DynamicSerializerMethodField</code> is a wraper of the <code>SerializerMethodField</code>, it adds a parsed query argument from a parent serializer to a method bound to a <code>SerializerMethodField</code>, this parsed query argument can be passed to a serializer used within a method to allow further querying. For example in the scenario below we are using <code>DynamicSerializerMethodField</code> because we want to be able to query <code>related_books</code> field.</p> <pre><code>from django_restql.mixins import DynamicFieldsMixin\nfrom django_restql.fields import DynamicSerializerMethodField\n\n\nclass CourseSerializer(DynamicFieldsMixin, serializers.ModelSerializer):\n    # Use `DynamicSerializerMethodField` instead of `SerializerMethodField`\n    # if you want to be able to query `related_books`\n    related_books = DynamicSerializerMethodField()\n    class Meta:\n        model = Course\n        fields = ['name', 'code', 'related_books']\n\n    def get_related_books(self, obj, parsed_query):\n        # With `DynamicSerializerMethodField` you get this extra\n        # `parsed_query` argument in addition to `obj`\n        books = obj.books.all()\n\n        # You can do what ever you want in here\n\n        # `parsed_query` param is passed to BookSerializer to allow further querying\n        serializer = BookSerializer(\n            books,\n            many=True, \n            parsed_query=parsed_query\n        )\n        return serializer.data\n</code></pre> <p><code>GET /course/?query={name, related_books}</code></p> <pre><code>[\n    {\n        \"name\": \"Data Structures\",\n        \"related_books\": [\n            {\"title\": \"Advanced Data Structures\", \"author\": \"S.Mobit\"},\n            {\"title\": \"Basic Data Structures\", \"author\": \"S.Mobit\"}\n        ]\n    }\n]\n</code></pre> <p></p> <p><code>GET /course/?query={name, related_books{title}}</code></p> <pre><code>[\n    {\n        \"name\": \"Data Structures\",\n        \"related_books\": [\n            {\"title\": \"Advanced Data Structures\"},\n            {\"title\": \"Basic Data Structures\"}\n        ]\n    }\n]\n</code></pre> <p></p>"},{"location":"querying_data/#dynamicfieldsmixin-kwargs","title":"DynamicFieldsMixin kwargs","text":"<p><code>DynamicFieldsMixin</code> accepts extra kwargs in addition to those accepted by a serializer, these extra kwargs can be used to do more customizations on a serializer as explained below.</p>"},{"location":"querying_data/#fields-kwarg","title":"fields kwarg","text":"<p>With Django RESTQL you can specify fields to be included when instantiating a serializer, this provides a way to refilter fields on nested fields(i.e you can opt to remove some fields on a nested field). Below is an example which shows how you can specify fields to be included on nested resources. </p> <pre><code>from rest_framework import serializers\nfrom django.contrib.auth.models import User\nfrom django_restql.mixins import DynamicFieldsMixin\n\nfrom app.models import Book, Course\n\n\nclass BookSerializer(DynamicFieldsMixin, serializers.ModelSerializer):\n    class Meta:\n        model = Book\n        fields = ['id', 'title', 'author']\n\n\nclass CourseSerializer(DynamicFieldsMixin, serializers.ModelSerializer):\n    books = BookSerializer(many=True, read_only=True, fields=[\"title\"])\n    class Meta:\n        model = Course\n        fields = ['name', 'code', 'books']\n</code></pre> <p><code>GET /courses/</code></p> <pre><code>[\n    {\n        \"name\": \"Computer Programming\",\n        \"code\": \"CS50\",\n        \"books\": [\n            {\"title\": \"Computer Programming Basics\"},\n            {\"title\": \"Data structures\"}\n        ]\n    },\n    ...\n]\n</code></pre> <p>As you see from the response above, the nested resource(book) has only one field(title) as specified on  <code>fields=[\"title\"]</code> kwarg during instantiating BookSerializer, so if you send a request like </p> <p><code>GET /course?query={name, code, books{title, author}}</code> </p> <p>you will get an error that <code>author</code> field is not found because it was not included here <code>fields=[\"title\"]</code>.</p>"},{"location":"querying_data/#exclude-kwarg","title":"exclude kwarg","text":"<p>You can also specify fields to be excluded when instantiating a serializer by using <code>exclude</code> kwarg, below is an example which shows how to use <code>exclude</code> kwarg.</p> <pre><code>from rest_framework import serializers\nfrom django_restql.mixins import DynamicFieldsMixin\n\nfrom app.models import Book, Course\n\n\nclass BookSerializer(DynamicFieldsMixin, serializers.ModelSerializer):\n    class Meta:\n        model = Book\n        fields = ['id', 'title', 'author']\n\n\nclass CourseSerializer(DynamicFieldsMixin, serializers.ModelSerializer):\n    books = BookSerializer(many=True, read_only=True, exclude=[\"author\"])\n    class Meta:\n        model = Course\n        fields = ['name', 'code', 'books']\n</code></pre> <p><code>GET /courses/</code></p> <pre><code>[\n    {\n        \"name\": \"Computer Programming\",\n        \"code\": \"CS50\",\n        \"books\": [\n            {\"id\": 1, \"title\": \"Computer Programming Basics\"},\n            {\"id\": 2, \"title\": \"Data structures\"}\n        ]\n    },\n    ...\n]\n</code></pre> <p>From the response above you can see that <code>author</code> field has been excluded fom book nested resource as specified on  <code>exclude=[\"author\"]</code> kwarg during instantiating BookSerializer.</p> <p>Note</p> <p><code>fields</code> and <code>exclude</code> kwargs have no effect when you access the resources directly, so when you access books you will still get all fields i.e</p> <p><code>GET /books/</code></p> <pre><code>[\n    {\n        \"id\": 1,\n        \"title\": \"Computer Programming Basics\",\n        \"author\": \"S.Mobit\"\n    },\n    ...\n]\n</code></pre> <p>So you can see that all fields have appeared as specified on <code>fields = ['id', 'title', 'author']</code> on BookSerializer class. </p>"},{"location":"querying_data/#query-kwarg","title":"query kwarg","text":"<p>Django RESTQL allows you to query fields by using <code>query</code> kwarg too, this is used if you don't want to get your query string from a request parameter, in fact <code>DynamicFieldsMixin</code> can work independently without using request. So by using <code>query</code> kwarg if you have serializers like </p> <pre><code>from rest_framework import serializers\nfrom django_restql.mixins import DynamicFieldsMixin\n\nfrom app.models import Book, Course\n\n\nclass BookSerializer(DynamicFieldsMixin, serializers.ModelSerializer):\n    class Meta:\n        model = Book\n        fields = ['id', 'title', 'author']\n\n\nclass CourseSerializer(DynamicFieldsMixin, serializers.ModelSerializer):\n    books = BookSerializer(many=True, read_only=True, exclude=[\"author\"])\n    class Meta:\n        model = Course\n        fields = ['name', 'code', 'books']\n</code></pre> <p>You can query fields as  </p> <pre><code>objs = Course.objects.all()\nquery = \"{name, books{title}}\"\nserializer = CourseSerializer(objs, many=True, query=query)\nprint(serializer.data)\n\n# This will print\n[\n    {\n        \"name\": \"Computer Programming\",\n        \"books\": [\n            {\"title\": \"Computer Programming Basics\"},\n            {\"title\": \"Data structures\"}\n        ]\n    },\n    ...\n]\n</code></pre> <p>As you see this doesn't need a request or view to work, you can use it anywhere as long as you pass your query string to a <code>query</code> kwarg.</p>"},{"location":"querying_data/#parsed_query-kwarg","title":"parsed_query kwarg","text":"<p>In addition to <code>query</code> kwarg, Django RESTQL allows you to query fields by using <code>parsed_query</code> kwarg. Here <code>parsed_query</code> is a query which has been parsed by a <code>QueryParser</code>. You probably won't need to use this directly as you are not adviced to write parsed query yourself, so the value of <code>parsed_query</code> kwarg should be something coming from <code>QueryParser</code>. If you have serializers like </p> <pre><code>from rest_framework import serializers\nfrom django_restql.mixins import DynamicFieldsMixin\n\nfrom app.models import Book, Course\n\n\nclass BookSerializer(DynamicFieldsMixin, serializers.ModelSerializer):\n    class Meta:\n        model = Book\n        fields = ['id', 'title', 'author']\n\n\nclass CourseSerializer(DynamicFieldsMixin, serializers.ModelSerializer):\n    books = BookSerializer(many=True, read_only=True, exclude=[\"author\"])\n    class Meta:\n        model = Course\n        fields = ['name', 'code', 'books']\n</code></pre> <p>You can query fields by using <code>parsed_query</code> kwarg as follows</p> <pre><code>import QueryParser from django_restql.parser\n\nobjs = Course.objects.all()\nquery = \"{name, books{title}}\"\n\n# You have to parse your query string first\nparser = QueryParser()\nparsed_query = parser.parse(query)\n\nserializer = CourseSerializer(objs, many=True, parsed_query=parsed_query)\nprint(serializer.data)\n\n# This will print\n[\n    {\n        \"name\": \"Computer Programming\",\n        \"books\": [\n            {\"title\": \"Computer Programming Basics\"},\n            {\"title\": \"Data structures\"}\n        ]\n    },\n    ...\n]\n</code></pre> <p><code>parsed_query</code> kwarg is often used with <code>DynamicMethodField</code> to pass part of parsed query to nested fields to allow further querying.</p>"},{"location":"querying_data/#return_pk-kwarg","title":"return_pk kwarg","text":"<p>With Django RESTQL you can specify whether to return nested resource pk or data. Below is an example which shows how we can use <code>return_pk</code> kwarg.</p> <pre><code>from rest_framework import serializers\nfrom django_restql.mixins import DynamicFieldsMixin\n\nfrom app.models import Book, Course\n\n\nclass BookSerializer(DynamicFieldsMixin, serializers.ModelSerializer):\n    class Meta:\n        model = Book\n        fields = ['id', 'title', 'author']\n\n\nclass CourseSerializer(DynamicFieldsMixin, serializers.ModelSerializer):\n    books = BookSerializer(many=True, read_only=True, return_pk=True)\n    class Meta:\n        model = Course\n        fields = ['name', 'code', 'books']\n</code></pre> <p><code>GET /course/</code></p> <pre><code>[\n    {\n        \"name\": \"Computer Programming\",\n        \"code\": \"CS50\",\n        \"books\": [1, 2]\n    },\n    ...\n]\n</code></pre> <p>So you can see that on a nested field <code>books</code> pks have been returned instead of books data as specified on <code>return_pk=True</code> kwarg on <code>BookSerializer</code>. </p>"},{"location":"querying_data/#disable_dynamic_fields-kwarg","title":"disable_dynamic_fields kwarg","text":"<p>Sometimes there are cases where you want to disable fields filtering with on a specific nested field, Django RESTQL allows you to do so by using <code>disable_dynamic_fields</code> kwarg when instantiating a serializer. Below is an example which shows how to use <code>disable_dynamic_fields</code> kwarg.</p> <pre><code>from rest_framework import serializers\nfrom django_restql.mixins import DynamicFieldsMixin\n\nfrom app.models import Book, Course\n\n\nclass BookSerializer(DynamicFieldsMixin, serializers.ModelSerializer):\n    class Meta:\n        model = Book\n        fields = ['id', 'title', 'author']\n\n\nclass CourseSerializer(DynamicFieldsMixin, serializers.ModelSerializer):\n    # Disable fields filtering on this field\n    books = BookSerializer(many=True, read_only=True, disable_dynamic_fields=True)\n    class Meta:\n        model = Course\n        fields = ['name', 'code', 'books']\n</code></pre> <p><code>GET /course/?query={name, books{title}}</code></p> <pre><code>[\n    {\n        \"name\": \"Computer Programming\",\n        \"books\": [\n            {\"id\": 1, \"title\": \"Computer Programming Basics\", \"author\": \"J.Vough\"},\n            {\"id\": 2, \"title\": \"Data structures\", \"author\": \"D.Denis\"}\n        ]\n    },\n    ...\n]\n</code></pre> <p>So you can see that even though the query asked for only <code>title</code> field under <code>books</code>, all fields have been returned, so this means fields filtering has applied on <code>CourseSerializer</code> but not on <code>BookSerializer</code> because we used <code>disable_dynamic_fields=True</code> on it. </p>"},{"location":"querying_data/#query-arguments","title":"Query arguments","text":"<p>Just like GraphQL, Django RESTQL allows you to pass arguments. These arguments can be used to do filtering, pagination, sorting and other stuffs that you would like them to do. Below is a syntax for passing arguments</p> <pre><code>query = (age: 18){\n    name,\n    age,\n    location(country: Canada, city: Toronto){\n        country,\n        city\n    }\n}\n</code></pre> <p>Here we have three arguments, <code>age</code>, <code>country</code> and <code>city</code> and their corresponding values.</p> <p>To escape any special character in a string(including <code>, : \" ' {} ()</code>) use backslash <code>\\</code>, single quote <code>'</code> or double quote <code>\"</code>, also if you want to escape double quote you can use single quote and vice versa. Escaping is very useful if you are dealing with data containing special characters e.g time, dates, lists, texts etc. Below is an example which contain an argument with a date type.</p> <pre><code>query = (age: 18, join_date__lt: '2020-04-27T23:02:32Z'){\n    name,\n    age,\n    location(country: 'Canada', city: 'Toronto'){\n        country,\n        city\n    }\n}\n</code></pre>"},{"location":"querying_data/#query-arguments-data-types","title":"Query arguments data types","text":"<p>Django RESTQL supports five primitive data types for query arguments which are <code>String</code>, <code>Int</code>, <code>Float</code>, <code>Boolean</code>, and <code>null</code></p> <p>The table below shows possible argument values and their corresponding python values</p> Argument Value Python Value String(e.g \"Hi!\" or 'Hi!') Python String(e.g \"Hi!\" or 'Hi!') Int(e.g 25) Python Int(e.g 25) Float(e.g 25.34) Python Float(e.g 25.34) true True false False null None <p>Below is a query showing how these data types are used</p> <pre><code>query = (age__gt: 18, is_active: true, location__ne: null, height__gt: 5.4){\n    name,\n    age,\n    location(country: \"Canada\"){\n        country,\n        city\n    }\n}\n</code></pre>"},{"location":"querying_data/#filtering-pagination-with-query-arguments","title":"Filtering &amp; pagination with query arguments","text":"<p>As mentioned before you can use query arguments to do filtering and pagination, Django RESTQL itself doesn't do filtering or pagination but it can help you to convert query arguments into query parameters from there you can use any library which you want to do the actual filtering or any pagination class to do pagination as long as they work with query parameters. To convert query arguments into query parameters all you need to do is inherit <code>QueryArgumentsMixin</code> in your viewset, that's it. For example</p> <pre><code># views.py\n\nfrom rest_framework import viewsets\nfrom django_restql.mixins import QueryArgumentsMixin\n\nclass StudentViewSet(QueryArgumentsMixin, viewsets.ModelViewSet):\n    serializer_class = StudentSerializer\n    queryset = Student.objects.all()\n    filter_fields = {\n        'name': ['exact'],\n        'age': ['exact'],\n        'location__country': ['exact'],\n        'location__city': ['exact'],\n    }\n</code></pre> <p>Whether you are using django-filter or djangorestframework-filters or any filter backend to do the actual filtering, Once you've configured it, you can continue to use all of the features found in filter backend of your choise as usual. The purpose of Django RESTQL on filtering is only to generate query parameters form query arguments. For example if you have a query like</p> <pre><code>query = (age: 18){\n    name,\n    age,\n    location(country: Canada, city: Toronto){\n        country,\n        city\n    }\n}\n</code></pre> <p>Django RESTQL would generate three query parameters from this as shown below</p> <pre><code>query_params = {\"age\": 18, \"location__country\": \"Canada\", \"location__city\": \"Toronto\"}\n</code></pre> <p>These will be used by the filter backend you have set to do the actual filtering.</p> <p>The same applies to pagination, sorting etc, once you have configured your pagination class whether it's <code>PageNumberPagination</code>, <code>LimitOffsetPagination</code>, <code>CursorPagination</code> or a custom, you will be able do it with query arguments. For example if you're using <code>LimitOffsetPagination</code> and you have a query like </p> <pre><code>query = (limit: 20, offset: 50){\n    name,\n    age,\n    location{\n        country,\n        city\n    }\n}\n</code></pre> <p>Django RESTQL would generate two query parameters from this as shown below</p> <pre><code>query_params = {\"limit\": 20, \"offset\": 50}\n</code></pre> <p>These will be used by pagination class you have set to do the actual pagination.</p> <p>So to use query arguments as query parameters all you need to do is inherit <code>QueryArgumentsMixin</code> to your viewset to convert query arguments into query parameters, from there you can use whatever you want to accomplish whatever with those generated query parameters.</p>"},{"location":"querying_data/#setting-up-eager-loading","title":"Setting up eager loading","text":"<p>Often times, using <code>prefetch_related</code> or <code>select_related</code> on a view queryset can help speed up the serialization. For example, if you had a many-to-many relation like Books to a Course, it's usually more efficient to call <code>prefetch_related</code> on the books so that serializing a list of courses only triggers one additional query, instead of a number of queries equal to the number of courses.</p> <p><code>EagerLoadingMixin</code> gives access to <code>prefetch_related</code> and <code>select_related</code> properties, these two are dictionaries that match serializer field names to respective values that would be passed into <code>prefetch_related</code> or <code>select_related</code>. Take the following serializers as examples.</p> <pre><code>class CourseSerializer(DynamicFieldsMixin, serializers.ModelSerializer):\n    books = BookSerializer(many=True, read_only=True)\n\n    class Meta:\n        model = Course\n        fields = ['name', 'code', 'books']\n\nclass StudentSerializer(DynamicFieldsMixin, serializers.ModelSerializer):\n    program = CourseSerializer(source=\"course\", many=False, read_only=True)\n    phone_numbers = PhoneSerializer(many=True, read_only=True)\n\n    class Meta:\n        model = Student\n        fields = ['name', 'age', 'program', 'phone_numbers']\n</code></pre> <p>In a view, these can be used as described earlier in this documentation. However, if prefetching of <code>books</code> always happened, but we did not ask for <code>{program}</code> or <code>program{books}</code>, then we did an additional query for nothing. Conversely, not prefetching can lead to even more queries being triggered. When leveraging the <code>EagerLoadingMixin</code> on a view, the specific fields that warrant a <code>select_related</code> or <code>prefetch_related</code> can be described.</p>"},{"location":"querying_data/#syntax-for-prefetch_related-and-select_related","title":"Syntax for prefetch_related and select_related","text":"<p>The format of syntax for <code>select_related</code> and  <code>prefetch_related</code> is as follows</p> <pre><code>select_related = {\"serializer_field_name\": [\"field_to_select\"]}\nprefetch_related = {\"serializer_field_name\": [\"field_to_prefetch\"]}\n</code></pre> <p>If you are selecting or prefetching one field per serializer field name you can use</p> <pre><code>select_related = {\"serializer_field_name\": \"field_to_select\"}\nprefetch_related = {\"serializer_field_name\": \"field_to_prefetch\"}\n</code></pre> <p>Syntax Interpretation</p> <ul> <li><code>serializer_field_name</code> stands for the name of the field to prefetch or select(as named on a serializer).</li> <li><code>fields_to_select</code> stands for argument(s) to pass when calling <code>select_related</code> method.</li> <li><code>fields_to_prefetch</code> stands for arguments(s) to pass when calling <code>prefetch_related</code> method. This can be a string or <code>Prefetch</code> object.</li> <li>If you want to select or prefetch nested field use dot(.) to separate parent and child fields on <code>serializer_field_name</code> eg <code>parent.child</code>.</li> </ul>"},{"location":"querying_data/#example-of-eagerloadingmixin-usage","title":"Example of EagerLoadingMixin usageExample QueriesMore example to get you comfortable with the syntax","text":"<pre><code>from rest_framework import viewsets\nfrom django_restql.mixins import EagerLoadingMixin\nfrom myapp.serializers import StudentSerializer\nfrom myapp.models import Student\n\nclass StudentViewSet(EagerLoadingMixin, viewsets.ModelViewSet):\n    serializer_class = StudentSerializer\n    queryset = Student.objects.all()\n\n    # The Interpretation of this is \n    # Select `course` only if program field is included in a query\n    select_related = {\n        \"program\": \"course\"\n    }\n\n    # The Interpretation of this is \n    # Prefetch `course__books` only if program or program.books \n    # fields are included in a query\n    prefetch_related = {\n        \"program.books\": \"course__books\"\n    }\n</code></pre> <ul> <li> <p><code>{name}</code>:  \u00a0\u00a0 Neither <code>select_related</code> or <code>prefetch_related</code> will be run since neither field is present on the serializer for this query.</p> </li> <li> <p><code>{program}</code>: \u00a0\u00a0 Both <code>select_related</code> and <code>prefetch_related</code> will be run, since <code>program</code> is present in it's entirety (including the <code>books</code> field).</p> </li> <li> <p><code>{program{name}}</code>: \u00a0\u00a0 Only <code>select_related</code> will be run, since <code>books</code> are not present on the program fields.</p> </li> <li> <p><code>{program{books}}</code>: \u00a0\u00a0 Both will be run here as well, since this explicitly fetches books.</p> </li> </ul> <p>Assuming this is the structure of the model and corresponding field types </p> <pre><code>user = {\n    username,        # string\n    birthdate,       # string\n    location {       # foreign key related field\n        country,     # string\n        city         # string\n    },\n    contact {        # foreign key related field\n        email,       # string\n        phone {      # foreign key related field\n            number,  # string\n            type     # string\n        }\n    }\n    articles {       # many related field\n        title,       # string\n        body,        # text\n        reviews {    # many related field\n            comment, # string\n            rating   # number\n        }\n    }\n}\n</code></pre> <p>Here is how <code>select_related</code> and <code>prefetch_related</code> could be written for this model</p> <pre><code>select_related = {\n    \"location\": \"location\",\n    \"contact\": \"contact\",\n    \"contact.phone\": \"contact__phone\"\n}\n\nprefetch_related = {\n    \"articles\": Prefetch(\"articles\", queryset=Article.objects.all()),\n    \"articles.reviews\": \"articles__reviews\"\n}\n</code></pre>"},{"location":"querying_data/#known-caveats","title":"Known Caveats","text":"<p>When prefetching with a <code>to_attr</code>, ensure that there are no collisions. Django does not allow multiple prefetches with the same <code>to_attr</code> on the same queryset.</p> <p>When prefetching and calling <code>select_related</code> on a field, Django may error, since the ORM does allow prefetching a selectable field, but not both at the same time.</p>"},{"location":"settings/","title":"Settings","text":"<p>Configuration for Django RESTQL is all namespaced inside a single Django setting named <code>RESTQL</code>, below is a list of what you can configure under <code>RESTQL</code> setting.</p>"},{"location":"settings/#query_param_name","title":"QUERY_PARAM_NAME","text":"<p>The default value for this is <code>query</code>. If you don't want to use the name <code>query</code> as your parameter, you can change it with<code>QUERY_PARAM_NAME</code> on settings file e.g</p> <pre><code># settings.py file\nRESTQL = {\n    'QUERY_PARAM_NAME': 'your_favourite_name'\n}\n</code></pre> <p>Now you can use the name <code>your_favourite_name</code> as your query parameter. E.g</p> <p><code>GET /users/?your_favourite_name={id, username}</code></p>"},{"location":"settings/#max_alias_len","title":"MAX_ALIAS_LEN","text":"<p>The default value for this is 50. When creating aliases this setting limit the number of characters allowed in aliases. This setting prevents DoS like attacks to API which might be caused by clients specifying a really really long alias which might increase network usage. If you want to change the default value, do as follows</p> <pre><code># settings.py file\nRESTQL = {\n    'MAX_ALIAS_LEN': 100  # Put the value that you want here\n}\n</code></pre>"},{"location":"settings/#auto_apply_eager_loading","title":"AUTO_APPLY_EAGER_LOADING","text":"<p>The default value for this is <code>True</code>. When using the <code>EagerLoadingMixin</code>, this setting controls if the mappings for <code>select_related</code> and <code>prefetch_related</code> are applied automatically when calling <code>get_queryset</code>. To turn it off, set the <code>AUTO_APPLY_EAGER_LOADING</code> setting or <code>auto_apply_eager_loading</code> attribute on the view to <code>False</code>.</p> <pre><code># settings.py file\n# This will turn off auto apply eager loading globally\nRESTQL = {\n    'AUTO_APPLY_EAGER_LOADING': False\n}\n</code></pre> <p>If auto apply eager loading is turned off, the method <code>apply_eager_loading</code> can still be used on your queryset if you wish to select or prefetch related fields according to your conditions, For example you can check if there was a query parameter passed in by using <code>has_restql_query_param</code>, if true then apply eager loading otherwise return a normal queryset.</p> <pre><code>from rest_framework import viewsets\nfrom django_restql.mixins import EagerLoadingMixin\nfrom myapp.serializers import StudentSerializer\nfrom myapp.models import Student\n\nclass StudentViewSet(EagerLoadingMixin, viewsets.ModelViewSet):\n    serializer_class = StudentSerializer\n    queryset = Student.objects.all()\n\n    # Turn off auto apply eager loading per view\n    # This overrides the `AUTO_APPLY_EAGER_LOADING` setting on this view\n    auto_apply_eager_loading = False\n    select_related = {\n        \"program\": \"course\"\n    }\n    prefetch_related = {\n        \"program.books\": \"course__books\"\n    }\n\n    def get_queryset(self):\n        queryset = super().get_queryset()\n        if self.has_restql_query_param:\n            queryset = self.apply_eager_loading(queryset)\n        return queryset\n</code></pre>"}]}